# Цель работы
Это продолжение работы (после Мандельброта) по оптимизации програм с использованием SIMD команд

# Ход работы
1. Написал наивную реализацю
2. Написал оптимизированную реализацию
3. Измерил производительность оптимизировнной и наивной версии с учётом и без оптимизации компилятором
4. Воспользовался инструментом godbolt.org и сравнил фрагменты кода на Си и инструкции, которые получаются на выходе компилятор
5. Рассмотрел наивную реализацию, которая рассчитывает каждый пиксель отдельно
6. Рассмотрел векторизованную версию с использованием SIMD команд
7. Сделал вывод

# Сравнение выхода компилятора
Приведу код для рассчёта цвета пикселя по формуле: 
`color = color_front * alpha + color_back * (1 - alpha)`, где `alpha` - альфа-составляющая заднего фона, выраженная в значении от 0 до 1. Чтобы не проводить вычисления в нецелых числах и приводить их к целым

```
    uint32_t front_color = *(uint32_t*) (front_ptr + pos);
    uint32_t  back_color = *(uint32_t*) ( back_ptr + pos);

    uint32_t alpha = (front_color >> 0x18) & 0xFF;

    uint32_t a = (uint16_t)  ((back_color >> 0x18) & 0xFF);

    uint32_t r = ((uint16_t) ( front_color          & 0xFF) * alpha +
                  (uint16_t) (  back_color          & 0xFF) * (255 - alpha)) >> 8;

    uint32_t g = ((uint16_t) ((front_color >> 0x8 ) & 0xFF) * alpha +
                  (uint16_t) (( back_color >> 0x8 ) & 0xFF) * (255 - alpha)) >> 8;

    uint32_t b = ((uint16_t) ((front_color >> 0x10) & 0xFF) * alpha +
                  (uint16_t) (( back_color >> 0x10) & 0xFF) * (255 - alpha)) >> 8;

    *(uint32_t*) (conf->res + pos) = (a << 0x18) +
                                     (b << 0x10) +
                                     (g <<  0x8) + r;
```

## Наивная версия с `-O2`:
```
```

## Оптимизировнная версия с `-O2`:
```
```

# Результаты измерений
Аналогично задаче по построение множества Мандельброта, чтобы замерить именно производительность вычисления, я проводил вычисления картинки фиксированное количество раз, в моём случае 200, и с его учётом измерял количество кадров в секунду. Так я смог пренебречь затратами на отрисовку кадра по сравнению с её расчётом, искусственно сместив вес вычислений

| FPS              | `-O0`  | `-O2`   |
|------------------|--------|---------|
| Оптимизированная | 376.90 | 2645.42 |
| Наивная          | 255.70 | 501.33  |

Я привёл результаты замеров с флагами `-O0` и `-O2` для того, чтобы показать:
1. Компилятор пытается использовать **XMM** регистры для ускорения расчётов с плавающей точкой
2. Компилятор может оптимизировать код, написанный с использованием интринсиков, в отличие от кода с ассемблерными вставками

Таким образом, исходя из данных в таблице, я получил ускорение программы (сравнивая версии с оптимизациями компилятора) примерно в 12 раз

